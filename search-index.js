var searchIndex = {};
searchIndex["casm"] = {"doc":"","items":[[5,"run","casm","Runs the program",null,{"inputs":[],"output":{"name":"result"}}],[5,"scan_files","","Creates a unique set of music files from the configuration data.  It expands globs and walks directories",null,{"inputs":[{"name":"str"},{"name":"vec"},{"name":"option"}],"output":{"name":"hashset"}}],[5,"process_files","","Runs the processing and copying on each file.  This is done in a multithreaded manner and shows a progressbar.",null,{"inputs":[{"name":"hashset"},{"name":"str"},{"name":"str"},{"name":"convertprofile"}],"output":null}],[0,"codec","","",null,null],[3,"Codec","casm::codec","A codec type for storing basic metadata used for conversion later.",null,null],[12,"name","","The name of the codec, as specified in enum ffmpeg::codec::id::Id",0,null],[12,"lossless","","Whether the codec is lossless or lossy",0,null],[12,"extension","","The extension of the codec (i.e. `.mp3`)",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_acceptable","","Checks to see if the codec is one of the acceptable codecs as specified in the user configuration",0,null],[0,"config","casm","",null,null],[3,"Config","casm::config","The user-specified config",null,null],[12,"source_folder","","The source folder that all files are relative to (i.e. `~/Music/`)",1,null],[12,"dest_folder","","The dest folder to which all relative filenames will be appended (i.e. `/mnt/Internal_Storage/Music`)",1,null],[12,"exclude","","The regex that matches files to exclude, usually for instrumental tracks",1,null],[12,"files","","A list of files, folders, and glob patterns to convert (this will be unique'd later)",1,null],[12,"convert_profile","","Conversion-specific settings",1,null],[3,"ConvertProfile","","The conversion-specific parts of the user-specified config",null,null],[12,"target_format","","A `ffmpeg::codec::id::Id` that is supported (see gen_codec_types).  Files that are not already one of `acceptable_formats` will be converted to this format.",2,null],[12,"acceptable_formats","","A list of music types that are acceptable on the target.  If the source file is one of these, it will not be converted to target_format.  The list may include types: * `ffmpeg::codec::id::Id`s that are supported (see gen_codec_types) * `lossless` for all lossless files (not recommended, unless also combined with lossy) * `lossy` for all lossy files (recommended) I usually go with `lossy` here, so that I'm not converting between lossy formats (more loss!) but don't have giant lossy files on my phone.",2,null],[12,"bit_rate","","A target bit rate in KB/s (i.e. 320 or 128)",2,null],[17,"_IMPL_DESERIALIZE_FOR_Config","","",null,null],[17,"_IMPL_DESERIALIZE_FOR_ConvertProfile","","",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"config"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"config"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"convertprofile"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"convertprofile"}],"output":{"name":"bool"}}],[11,"new","","Creates a config struct from the configuration file",1,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[0,"musicfile","casm","",null,null],[3,"Musicfile","casm::musicfile","A struct that holds a music file",null,null],[12,"filename","","",3,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"musicfile"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"musicfile"}],"output":{"name":"bool"}}],[11,"hash","","",3,null],[11,"new","","Creates a new Musicfile, if it doesn't match the `exclude` regex",3,{"inputs":[{"name":"pathbuf"},{"name":"option"}],"output":{"name":"option"}}],[11,"process_file","","Analyzes the music file to determine whether or not it needs to be converted, and then converts and/or copies it",3,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"convertprofile"}],"output":{"name":"result"}}],[11,"get_codec","","Gets the codec from the music file via ffmpeg",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"should_write","","Determines whether or not a file at the destination should be overwritten.",3,{"inputs":[{"name":"self"},{"name":"pathbuf"}],"output":{"name":"bool"}}],[0,"transcoder","casm","",null,null],[3,"Transcoder","casm::transcoder","",null,null],[12,"stream","","",4,null],[12,"filter","","",4,null],[12,"decoder","","",4,null],[12,"encoder","","",4,null],[5,"filter","","",null,{"inputs":[{"name":"str"},{"name":"audio"},{"name":"audio"}],"output":{"name":"result"}}],[5,"transcoder","","",null,{"inputs":[{"name":"input"},{"name":"output"},{"name":"p"},{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[5,"convert","","",null,{"inputs":[{"name":"str"},{"name":"str"},{"name":"str"},{"name":"usize"}],"output":null}],[5,"select_best_rate","","Get the closest sample rate without going under, unless there is nothing above There are some issues with this.  Sample rate conversion can have some loss, and we're letting the user target a bitrate.  That said, we're mostly doing this to convert from 44.1khz to 48khz for opus.",null,{"inputs":[{"name":"i32"},{"name":"option"}],"output":{"name":"i32"}}],[0,"errors","casm","",null,null],[3,"Error","casm::errors","The Error type.",null,null],[12,"0","","The kind of the error.",5,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",6,null],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"ResultExt","","Additional methods for `Result`, for easy interaction with this crate.",null,null],[10,"chain_err","","If the `Result` is an `Err` then `chain_err` evaluates the closure, which returns some type that can be converted to `ErrorKind`, boxes the original error to store as the cause, then returns a new error containing the original error.",7,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",5,{"inputs":[{"name":"errorkind"},{"name":"state"}],"output":{"name":"error"}}],[11,"from_kind","","",5,null],[11,"with_chain","","",5,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"self"}}],[11,"kind","","",5,null],[11,"iter","","",5,{"inputs":[{"name":"self"}],"output":{"name":"errorchainiter"}}],[11,"backtrace","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"extract_backtrace","","",5,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",5,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",5,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"error"}}],[11,"kind","","Returns the kind of the error.",5,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","Iterates over the error chain.",5,{"inputs":[{"name":"self"}],"output":{"name":"errorchainiter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"description","","",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",5,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"deref","","",5,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","A string describing the error kind.",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",6,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",6,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[7,"ALL_CODECS","casm","",null,null]],"paths":[[3,"Codec"],[3,"Config"],[3,"ConvertProfile"],[3,"Musicfile"],[3,"Transcoder"],[3,"Error"],[4,"ErrorKind"],[8,"ResultExt"]]};
initSearch(searchIndex);
